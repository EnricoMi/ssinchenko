<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/ssinchenko/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=ssinchenko/livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>PySpark column lineage | Sem Sinchenko</title>
<meta name="keywords" content="spark, pyspark">
<meta name="description" content="In this post, I will show you how to use information from the spark plan to track data lineage at the column level. This approach will also works with recently introduced SparkConnect.">
<meta name="author" content="Sem Sinchenko">
<link rel="canonical" href="http://localhost:1313/ssinchenko/post/pyspark-column-lineage/">
<link crossorigin="anonymous" href="/ssinchenko/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/ssinchenko/images/fav/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/ssinchenko/images/fav/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/ssinchenko/images/fav/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/ssinchenko/images/fav/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/ssinchenko/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/ssinchenko/post/pyspark-column-lineage/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
















    
        <link rel="preconnect" href="https://plausible.io">
    <!-- Dev mode : We do not load plausible script to avoid bloating your stats -->

<!-- If you are using Content-Security-Policy, do not forget to add this code to your CSP : 
  script-src 'unsafe-inline' https://plausible.io
  connect-src 'unsafe-inline' https://plausible.io
  or just add the partial 'plausible_csp.html' to those 2 csp directives in your 'index.headers' file
-->



    
    <script>window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }</script>
    <script>
         
         
         
    </script>

    
















    
        <link rel="preconnect" href="https://plausible.io">
    <!-- Dev mode : We do not load plausible script to avoid bloating your stats -->

<!-- If you are using Content-Security-Policy, do not forget to add this code to your CSP : 
  script-src 'unsafe-inline' https://plausible.io
  connect-src 'unsafe-inline' https://plausible.io
  or just add the partial 'plausible_csp.html' to those 2 csp directives in your 'index.headers' file
-->



    
    <script>window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }</script>
    <script>
         
         
         
    </script>

    


  

<meta property="og:title" content="PySpark column lineage" />
<meta property="og:description" content="In this post, I will show you how to use information from the spark plan to track data lineage at the column level. This approach will also works with recently introduced SparkConnect." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/ssinchenko/post/pyspark-column-lineage/" />
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/f/f3/Apache_Spark_logo.svg" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2024-01-10T12:00:05+02:00" />
<meta property="article:modified_time" content="2024-01-10T12:00:05+02:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://upload.wikimedia.org/wikipedia/commons/f/f3/Apache_Spark_logo.svg" />
<meta name="twitter:title" content="PySpark column lineage"/>
<meta name="twitter:description" content="In this post, I will show you how to use information from the spark plan to track data lineage at the column level. This approach will also works with recently introduced SparkConnect."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/ssinchenko/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "PySpark column lineage",
      "item": "http://localhost:1313/ssinchenko/post/pyspark-column-lineage/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "PySpark column lineage",
  "name": "PySpark column lineage",
  "description": "In this post, I will show you how to use information from the spark plan to track data lineage at the column level. This approach will also works with recently introduced SparkConnect.",
  "keywords": [
    "spark", "pyspark"
  ],
  "articleBody": " PySpark column-level lineage Introduction In this post, I will show you how to use information from the spark plan to track data lineage at the column level. Let's say we have the following DataFrame object:\nfrom pyspark.sql import SparkSession, functions as F spark = SparkSession.builder.master(\"local[*]\").getOrCreate() dat = spark.read.csv(\"/home/sem/github/farsante/h2o-data-rust/J1_1e8_1e5_5.csv\", header=True) dat.printSchema() Result:\nroot |-- id1: string (nullable = true) |-- id2: string (nullable = true) |-- id4: string (nullable = true) |-- id5: string (nullable = true) |-- v2: string (nullable = true) Let's create some transformations on top of our dat object:\ndat_new = ( dat.withColumn(\"id1_renamed\", F.col(\"id1\")) .withColumn(\"id1_and_id2\", F.concat_ws(\"_\", F.col(\"id1\"), F.col(\"id2\"))) .withColumn(\"num1\", F.lit(1)) .withColumn(\"num2\", F.lit(2)) .filter(F.rand() \u003c= F.lit(0.5)) .select(\"id1_renamed\", \"id1_and_id2\", \"id1\", \"num1\", \"num2\") .withColumn(\"hash_id\", F.hash(\"id1_and_id2\")) .join(dat.select(\"id1\", \"id4\"), on=[\"id1\"], how=\"left\") .withColumn(\"hash_of_two_ids\", F.concat_ws(\"_\", \"id4\", \"hash_id\")) .groupBy(\"id1_renamed\") .agg(F.count_distinct(\"hash_of_two_ids\").alias(\"cnt_ids\"), F.sum(F.col(\"num1\") + F.col(\"num2\")).alias(\"sum_col\")) ) Even with such a small transformation, it is not at all obvious which column is coming from where. Tracking transformations is the goal of Data Lineage. There are several types of data lineage:\nAt the data source level, when we want to track all data sources in the process of our transformations; At the column level, when we want to track how which column was transformed during the process. In this post I will focus on the second one, but the first one can be achieved in a similar way. But to implement it, we need to understand a little bit how Apache Spark works, how lazy computations work, and what the Directed Acyclic Graph of computations is.\nA short introduction to spark computations model and Catalyst You can get a deeper dive by reading an original paper about Spark SQL and Catalyst: Spark SQL: Relational Data Processing in Spark. I will just give a top-level overview.\nWhen you apply a transformation, like withColumn(\"num1\", F.lit(1)), Spark only adds a step to the computation graph, but does not add an actual column to the PySpark DataFrame you are working with. So at any moment, DataFrame is not a \"real\" data, but just a directed graph of computation steps. PySpark provides a way to get a string representation of the plan, to work with a plan as with a real graph data structure you need to use the Scala/Java API of Apache Spark. When you perform an action, like df.count() or df.write, Spark will get your computation graph and make an execution. This is a very simplified view, because in reality there are many different intermediate steps:\nTransforming the parsed logical plan into an analyzed logical plan by resolving sources and column references; Optimizing the logical plan by applying optimization rules (such as moving filter expressions to the beginning of the plan, or moving select expressions to the source column level); Generate different versions of physical plans based on the same optimized logical plan; Apply cost-based selection of the best physical plan; perform code generation based on the selected physical plan; Execute the code. For anyone who wants to better understand how spark works with plans and how optimizations can be applied, I highly recommend the book How query engines work by Andy Grow, creator of the Apache Arrow Datafusion.\nGetting a string-representation of plan in PySpark But for now, we just need the parsed logical plan, so let's make a simple Python function that returns it:\nimport contextlib from pyspark.sql import DataFrame def get_logical_plan(df: DataFrame) -\u003e str: with contextlib.redirect_stdout(StringIO()) as stdout: df.explain(extended=True) plan_lines = stdout.getvalue().split(\"\\n\") start_line = plan_lines.index(\"== Analyzed Logical Plan ==\") + 2 end_line = plan_lines.index(\"== Optimized Logical Plan ==\") return \"\\n\".join(plan_lines[start_line:end_line]) It may look overly complicated, but there is no other way to get a string representation of the analyzed logical plan from PySpark. df.explain returns nothing, instead it prints all plans (analyzed logical, optimized logical, physical) to standard output. That's why we need to use contextlib.redirect_stdout. You can check what the whole output of df.explain looks like. It is broken up by lines like == Analyzed Logical Plan == and similar. Also, the analyzed logical plan always starts from the schema of the DataFrame, so we need to add another line.\nLet's see what the plan looks like for our dat_new DataFrame that we created:\nget_logical_plan(dat_new) Aggregate [id1_renamed#2430], [id1_renamed#2430, count(distinct hash_of_two_ids#2491) AS cnt_ids#2508L, sum((num1#2445 + num2#2454)) AS sum_col#2510L] +- Project [id1#1321, id1_renamed#2430, id1_and_id2#2437, num1#2445, num2#2454, hash_id#2469, id4#2480, concat_ws(_, id4#2480, cast(hash_id#2469 as string)) AS hash_of_two_ids#2491] +- Project [id1#1321, id1_renamed#2430, id1_and_id2#2437, num1#2445, num2#2454, hash_id#2469, id4#2480] +- Join LeftOuter, (id1#1321 = id1#2478) :- Project [id1_renamed#2430, id1_and_id2#2437, id1#1321, num1#2445, num2#2454, hash(id1_and_id2#2437, 42) AS hash_id#2469] : +- Project [id1_renamed#2430, id1_and_id2#2437, id1#1321, num1#2445, num2#2454] : +- Filter (rand(-7677477572161899967) \u003c= 0.5) : +- Project [id1#1321, id2#1322, id4#1323, id5#1324, v2#1325, id1_renamed#2430, id1_and_id2#2437, num1#2445, 2 AS num2#2454] : +- Project [id1#1321, id2#1322, id4#1323, id5#1324, v2#1325, id1_renamed#2430, id1_and_id2#2437, 1 AS num1#2445] : +- Project [id1#1321, id2#1322, id4#1323, id5#1324, v2#1325, id1_renamed#2430, concat_ws(_, id1#1321, id2#1322) AS id1_and_id2#2437] : +- Project [id1#1321, id2#1322, id4#1323, id5#1324, v2#1325, id1#1321 AS id1_renamed#2430] : +- Relation [id1#1321,id2#1322,id4#1323,id5#1324,v2#1325] csv +- Project [id1#2478, id4#2480] +- Relation [id1#2478,id2#2479,id4#2480,id5#2481,v2#2482] csv As you can see, the analyzed logical plan contains all calculation steps from the last one to the first one (Relation ... csv). An important thing is that PySpark adds unique IDs to each column, so the final names in the plan are not real column names, but something like name#unique_id. This will help us a lot when we will create our column lineage parser, because it simplifies all things: you do not need to think about collisions or renaming, because PySpark has already solved all these problems!\nParsing plan to get column-lineage As you can see, there is a limited list of possible operations:\nRelation: mapping of columns to files or tables; Project~: any column operation, such as withColumn, withColumnRenamed, select, etc; Filter~: any filter operation; Join~: various types of join operations; Aggregate~: aggregate operations; There are also some additional cases like Union, but the union operation makes things very complex, so let's decide to avoid it. Just because if a plan contains Union it is very hard to parse it, because a column can appear in any side of a union-like operation…\nDefining an output data-structure and user API First, we need to define what our column lineage will look like and what the data structure representing the lineage will be. By design, the data lineage is a directed acyclic graph (or tree). One of the simplest ways to represent a graph-like structure is simply to use a list of edges (called an adjacency list). Nodes of our graph will contain not only ids, but also some additional information, like the description of the computation step. Let's store the attributes in a dict-like structure. And the API should be very simple: just a function that takes a DataFrame object and a column name. For simplicity, it might also be good to store the list of all nodes in the graph. Let's define the structure and a function signature:\nfrom dataclasses import dataclass @dataclass class ColumnLineageGraph: \"\"\"Structure to represent columnar data lineage.\"\"\" nodes: list[int] # list of hash values that represent nodes edges: list[list[int]] # list of edges in the form of list of pairs node_attrs: dict[int, str] # labels of nodes (expressions) def get_column_lineage(df: DataFrame, columns: str) -\u003e ColumnLineageGraph: raise NotImplementedError() Creating recursive parsing function We will be using a lot of regular expressions and we need to import them first:\nimport re Transforming from graph-nodes to column names It doesn't really matter that our logical plan is a list of strings. By design and idea, it is the tree structure, and the best way to traverse the tree is, of course, a recursion. Let's create an inner recursive function to traverse the plan:\ndef _node2column(node: str) -\u003e str: \"\"\"Inner function. Transform the node from plan to column name. Like: col_11#1234L -\u003e col_11. \"\"\" match_ = re.match(r\"([\\w\\d]+)#[\\w\\d]+\", node) if match_: return match_.groups()[0] We also need a way to get a node ID from the column name. To do this, let's add another simple function:\ndef _get_aliases(col: str, line: str) -\u003e tuple[list[str], str]: \"\"\"Inner function. Returns all the aliases from the expr and expr itself.\"\"\" alias_exp = _extract_alias_expressions(col, line) # Regexp to extract columns: each column has a pattern like col_name#1234 return (re.findall(r\"[\\w\\d]+#[\\w\\d]+\", alias_exp), alias_exp) Parsing ALIAS expressions One of the most complicated cases in a Spark plan is an alias. You may be faced with the following options:\nLiteral expressions, like 1 AS col#1234; Just an alias, like col1#1234 AS col2#1235; An alias to the expression, like (col1#1234 + col2#1235) AS col3#1236. And the last one can contain an unlimited number of nested expressions. It is almost impossible to parse such a case via regular expressions, looks like we need to balance parentheses, as in Leetcode easy task. I will use a counter based approach, where we have a counter of unbalanced parentheses and we reach the end of the expression when the counter is zero.\ndef _extract_alias_expressions(col: str, line: str) -\u003e str: \"\"\"Inner function. Extract expression before ... AS col from the line.\"\"\" num_close_parentheses = 0 # our counter idx = line.index(f\" AS {col}\") # the end of the alias expression we need to parse alias_expr = [] # buffer to store what we are parsing if line[idx - 1] != \")\": \"\"\"It is possible that there is no expression. It is the case when we just make a rename of the column. In the plan it will look like `col#123 AS col#321`; \"\"\" for j in range(idx - 1, 0, -1): alias_expr.append(line[j]) if line[j - 1] == \"[\": break if line[j - 1] == \" \": break return \"\".join(alias_expr)[::-1] \"\"\"In all other cases there will be `(` at the end of the expr before AS. Our goal is to go symbol by symbol back until we balance all the parentheses. \"\"\" for i in range(idx - 1, 0, -1): alias_expr.append(line[i]) if line[i] == \")\": # Add parenthesis num_close_parentheses += 1 if line[i] == \"(\": if num_close_parentheses == 1: # Parentheses are balanced break # Remove parenthesis num_close_parentheses -= 1 \"\"\"After balancing parentheses we need to parse leading expression. It is always here because we checked single alias case separately.\"\"\" for j in range(i, 0, -1): alias_expr.append(line[j]) if line[j - 1] == \"[\": break if line[j - 1] == \" \": break return \"\".join(alias_expr[::-1]) It may look like magic, so let's check how it works on examples from our real plan representation:\n_extract_alias_expressions( \"id1_and_id2#2437\", \"Project [id1#1321, id2#1322, id4#1323, id5#1324, v2#1325, id1_renamed#2430, concat_ws(_, id1#1321, id2#1322) AS id1_and_id2#2437]\" ) And the result is:\n'concat_ws((_, id1#1321, id2#1322)' Looks like it works! Finally some of the knowledge from the Leetcode tasks was put into practice!\nParsing aggregation-like expressions In most cases we do not need additional columns from the row of the plan, except for one that we are working with. The only exception is aggregation: it might be good to store information about aggregation keys in our final node attributes. Let's add a simple function to do this:\ndef _add_aggr_or_not(expr: str, line: str) -\u003e str: \"\"\"If the expr is aggregation we should add agg keys to the beginning.\"\"\" # We are checking for aggregation pattern match_ = re.match(r\"^[\\s\\+\\-:]*Aggregate\\s\\[([\\w\\d#,\\s]+)\\].*$\", line) if match_: agg_expr = match_.groups()[0] return ( \"GroupBy: \" + re.sub(r\"([\\w\\d]+)#([\\w\\d]+)\", r\"\\1\", agg_expr) + f\"\\n{expr}\" ) # If not just return an original expr return expr Building a final recursive parser Now we have everything we need. So let's go through the logical plan line by line, adding nodes and attributes to our graph structure:\ndef _get_graph(lines: list[str], node: str): nodes = [] edges = [] node_attrs = {} for i, l in enumerate(lines): # noqa: E741 \"\"\"Iteration over lines of logical plan.\"\"\" # We should use hash of line + node as a key in the graph. # It is not enough to use only hash of line because the same line # may be related to multiple nodes! # A good example is reading the CSV that is represented by one line! h = hash(l + node) # If the current node is not root we need to store hash of previous node. prev_h = None if not nodes else nodes[-1] if node not in l: continue if f\"AS {node}\" in l: \"\"\"It is a hard case, when a node is an alias to some expression.\"\"\" aliases, expr = _get_aliases(node, l) # For visualization we need to transform from nodes to columns expr = re.sub(r\"([\\w\\d]+)#([\\w\\d]+)\", r\"\\1\", expr) # Append a new node nodes.append(h) # Append expr as an attribute of the node node_attrs[h] = _add_aggr_or_not(f\"{expr} AS {_node2column(node)}\", l) if len(aliases) == 1: # It is the case of simple alis # Like col1#123 AS col2#321 # In this case we just replace an old node by new one. if prev_h: edges.append([h, prev_h]) node = aliases[0] else: # It is a case of complex expression. # Here we recursively go through all the nodes from expr. if prev_h: edges.append([h, prev_h]) for aa in aliases: # Get graph from sub-column sub_nodes, sub_edges, sub_attrs = _get_graph(lines[i:], aa) # Add everything to the current graph nodes.extend(sub_nodes) edges.extend(sub_edges) node_attrs = {**node_attrs, **sub_attrs} # Add connection between top subnode and node edges.append([sub_nodes[0], h]) return (nodes, edges, node_attrs) else: # Continue of the simple alias or expr case # In the future that may be more cases, that is the reason of nested if instead of elif if \"Relation\" in l: nodes.append(h) if prev_h: edges.append([h, prev_h]) # It is a pattern, related to data-sources (like CSV) match_ = re.match(r\"[\\s\\+\\-:]*Relation\\s\\[.*\\]\\s(\\w+)\", l) if match_: s_ = \"Read from {}: {}\" # Add data-source as a node node_attrs[h] = s_.format(match_.groups()[0], _node2column(node)) else: # We need it to avoid empty graphs and related runtime exceptions print(l) node_attrs[h] = f\"Relation to: {_node2column(node)}\" elif \"Join\" in l: nodes.append(h) if prev_h: edges.append([h, prev_h]) match_ = re.match(r\"[\\s\\+\\-:]*Join\\s(\\w+),\\s\\((.*)\\)\", l) if match_: join_type = match_.groups()[0] join_expr = match_.groups()[1] join_expr_clr = re.sub(r\"([\\w\\d]+)#([\\w\\d]+)\", r\"\\1\", join_expr) node_attrs[h] = f\"{join_type}: {join_expr_clr}\" else: continue if not nodes: # Just the case of empty return. We need to avoid it. # I'm not sure that line is reachable. nodes.append(h) node_attrs[h] = f\"Select: {_node2column(node)}\" return (nodes, edges, node_attrs) All together Now we are ready to put all the pieces together into a single function:\ndef get_column_lineage(df: DataFrame, column: str) -\u003e ColumnLineageGraph: \"\"\"Get data lineage on the level of the given column. Currently Union operation is not supported! API is unstable, no guarantee that custom spark operations or connectors won't break it! :param df: DataFrame :param column: column :returns: Struct with nodes, edges and attributes \"\"\" lines = get_plan_from_df(df, PlanType.ANALYZED_LOGICAL_PLAN).split(\"\\n\") # Top line should contain plan-id of our column. We need it. # Regular pattern of node is column#12345L or [\\w\\d]+#[\\w\\d]+ match_ = re.match(r\".*(\" + column + r\"#[\\w\\d]+).*\", lines[0]) if match_: node = match_.groups()[0] else: err = f\"There is no column {column} in the final schema of DF!\" raise KeyError(err) nodes, edges, attrs = _get_graph(lines, node) return ColumnLineageGraph(nodes, edges, attrs) Testing and drawing our implementation Let's see how our function works:\nget_column_lineage(dat_new, \"cnt_ids\") Will produce the following:\nColumnLineageGraph(nodes=[-3047688324833821294, 8934572903754805890, -22248459158511064, -3092611391038289840, 1490298382268190732, -6431655222193019101, -1002279244933706460], edges=[[8934572903754805890, -3047688324833821294], [-22248459158511064, 8934572903754805890], [1490298382268190732, -3092611391038289840], [-6431655222193019101, 1490298382268190732], [-1002279244933706460, 1490298382268190732], [-3092611391038289840, 8934572903754805890]], node_attrs={-3047688324833821294: 'GroupBy: id1_renamed\\ncount((distinct hash_of_two_ids) AS cnt_ids', 8934572903754805890: 'concat_ws((_, id4, cast(hash_id as string)) AS hash_of_two_ids', -22248459158511064: 'Read from csv: id4', -3092611391038289840: 'hash((id1_and_id2, 42) AS hash_id', 1490298382268190732: 'concat_ws((_, id1, id2) AS id1_and_id2', -6431655222193019101: 'Read from csv: id1', -1002279244933706460: 'Read from csv: id2'}) Looks like it works, at least in our simple case.\nDrawing the graph To draw the graph as a tree, let's use the Python library NetworkX. And GraphViz as the drawing engine. You need to install the following packages to use it:\nnetworkx pygraphviz matplotlib def plot_column_lineage_graph( df: DataFrame, column: str, ) -\u003e \"matplotlib.pyplot.Figure\": \"\"\"Plot the column lineage graph as matplotlib figure. :param df: DataFrame :param column: column :returns: matplotlib.pyplot.Figure \"\"\" try: import networkx as nx from networkx.drawing.nx_agraph import graphviz_layout except ModuleNotFoundError as e: err = \"NetworkX is not installed. Try `pip install networkx`. \" err += ( \"You may use `get_column_lineage` instead, that doesn't require NetworkX.\" ) raise ModuleNotFoundError(err) from e try: import matplotlib.pyplot as plt except ModuleNotFoundError as e: err = \"You need matplotlib installed to draw the Graph\" raise ModuleNotFoundError(err) from e import importlib if not importlib.util.find_spec(\"pygraphviz\"): err = \"You need to have pygraphviz installed to draw the Graph\" raise ModuleNotFoundError(err) lineage = get_column_lineage(df, column) g = nx.DiGraph() g.add_nodes_from(lineage.nodes) g.add_edges_from(lineage.edges) pos = graphviz_layout(g, prog=\"twopi\") pos_attrs = {} for node, coords in pos.items(): pos_attrs[node] = (coords[0], coords[1] + 10) nx.draw(g, pos=pos) nx.draw_networkx_labels(g, labels=lineage.node_attrs, pos=pos_attrs, clip_on=False) return plt.gcf() If we run it, we get the following:\nimport matplotlib.pyplot as plt col = \"cnt_ids\" f = plot_column_lineage_graph(dat_new, col) f.show() Looks exactly as what we need!\nAfterwards This functionality is mostly for educational purposes, to better understand how Spark Plan is organized. Another possible use case is if you need some simple inline Python code for this task. For real production data lineage on top of Spark, I recommend using a Spline Project!\n",
  "wordCount" : "2794",
  "inLanguage": "en",
  "image":"https://upload.wikimedia.org/wikipedia/commons/f/f3/Apache_Spark_logo.svg","datePublished": "2024-01-10T12:00:05+02:00",
  "dateModified": "2024-01-10T12:00:05+02:00",
  "author":{
    "@type": "Person",
    "name": "Sem Sinchenko"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/ssinchenko/post/pyspark-column-lineage/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sem Sinchenko",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/ssinchenko/images/fav/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/ssinchenko/" accesskey="h" title="Sem Sinchenko (Alt + H)">Sem Sinchenko</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/ssinchenko/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/ssinchenko/page/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/ssinchenko/page/cv/" title="CV">
                    <span>CV</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/ssinchenko/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/ssinchenko/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      PySpark column lineage
    </h1>
    <div class="post-meta"><span title='2024-01-10 12:00:05 +0200 +0200'>January 10, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Sem Sinchenko

</div>
  </header> 
<figure class="entry-cover"><img loading="eager" src="https://upload.wikimedia.org/wikipedia/commons/f/f3/Apache_Spark_logo.svg" alt="">
        
</figure>
  <div class="post-content">
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
PySpark column-level lineage
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<div id="outline-container-headline-2" class="outline-3">
<h3 id="headline-2">
Introduction
</h3>
<div id="outline-text-headline-2" class="outline-text-3">
<p>
In this post, I will show you how to use information from the spark plan to track data lineage at the column level. Let&#39;s say we have the following <code>DataFrame</code> object:</p>
<div class="src src-python">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="kn">import</span> <span class="n">SparkSession</span><span class="p">,</span> <span class="n">functions</span> <span class="k">as</span> <span class="n">F</span>
</span></span><span class="line"><span class="cl">  <span class="n">spark</span> <span class="o">=</span> <span class="n">SparkSession</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">master</span><span class="p">(</span><span class="s2">&#34;local[*]&#34;</span><span class="p">)</span><span class="o">.</span><span class="n">getOrCreate</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="n">dat</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">csv</span><span class="p">(</span><span class="s2">&#34;/home/sem/github/farsante/h2o-data-rust/J1_1e8_1e5_5.csv&#34;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">dat</span><span class="o">.</span><span class="n">printSchema</span><span class="p">()</span></span></span></code></pre></div>
</div>
<p>
Result:</p>
<div class="src src-shell">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">root
</span></span><span class="line"><span class="cl"> <span class="p">|</span>-- id1: string <span class="o">(</span><span class="nv">nullable</span> <span class="o">=</span> <span class="nb">true</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">|</span>-- id2: string <span class="o">(</span><span class="nv">nullable</span> <span class="o">=</span> <span class="nb">true</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">|</span>-- id4: string <span class="o">(</span><span class="nv">nullable</span> <span class="o">=</span> <span class="nb">true</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">|</span>-- id5: string <span class="o">(</span><span class="nv">nullable</span> <span class="o">=</span> <span class="nb">true</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">|</span>-- v2: string <span class="o">(</span><span class="nv">nullable</span> <span class="o">=</span> <span class="nb">true</span><span class="o">)</span></span></span></code></pre></div>
</div>
<p>
Let&#39;s create some transformations on top of our <code>dat</code> object:</p>
<div class="src src-python">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="n">dat_new</span> <span class="o">=</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">dat</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&#34;id1_renamed&#34;</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&#34;id1&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&#34;id1_and_id2&#34;</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">concat_ws</span><span class="p">(</span><span class="s2">&#34;_&#34;</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&#34;id1&#34;</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&#34;id2&#34;</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&#34;num1&#34;</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&#34;num2&#34;</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&#34;id1_renamed&#34;</span><span class="p">,</span> <span class="s2">&#34;id1_and_id2&#34;</span><span class="p">,</span> <span class="s2">&#34;id1&#34;</span><span class="p">,</span> <span class="s2">&#34;num1&#34;</span><span class="p">,</span> <span class="s2">&#34;num2&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&#34;hash_id&#34;</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">hash</span><span class="p">(</span><span class="s2">&#34;id1_and_id2&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dat</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&#34;id1&#34;</span><span class="p">,</span> <span class="s2">&#34;id4&#34;</span><span class="p">),</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&#34;id1&#34;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&#34;left&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&#34;hash_of_two_ids&#34;</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">concat_ws</span><span class="p">(</span><span class="s2">&#34;_&#34;</span><span class="p">,</span> <span class="s2">&#34;id4&#34;</span><span class="p">,</span> <span class="s2">&#34;hash_id&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="s2">&#34;id1_renamed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">count_distinct</span><span class="p">(</span><span class="s2">&#34;hash_of_two_ids&#34;</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&#34;cnt_ids&#34;</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&#34;num1&#34;</span><span class="p">)</span> <span class="o">+</span> <span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&#34;num2&#34;</span><span class="p">))</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&#34;sum_col&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span></span></span></code></pre></div>
</div>
<p>
Even with such a small transformation, it is not at all obvious which column is coming from where. Tracking transformations is the goal of <em>Data Lineage</em>. There are several types of data lineage:</p>
<ul>
<li>At the data source level, when we want to track all data sources in the process of our transformations;</li>
<li>At the column level, when we want to track how which column was transformed during the process.</li>
</ul>
<p>In this post I will focus on the second one, but the first one can be achieved in a similar way. But to implement it, we need to understand a little bit how Apache Spark works, how lazy computations work, and what the Directed Acyclic Graph of computations is.</p>
</div>
</div>
<div id="outline-container-headline-3" class="outline-3">
<h3 id="headline-3">
A short introduction to spark computations model and Catalyst
</h3>
<div id="outline-text-headline-3" class="outline-text-3">
<p>
You can get a deeper dive by reading an original paper about Spark SQL and Catalyst: <a href="https://people.csail.mit.edu/matei/papers/2015/sigmod_spark_sql.pdf">Spark SQL: Relational Data Processing in Spark</a>. I will just give a top-level overview.</p>
<p>
When you apply a transformation, like <code>withColumn(&#34;num1&#34;, F.lit(1))</code>, Spark only adds a step to the computation graph, but does not add an actual column to the PySpark DataFrame you are working with. So at any moment, DataFrame is not a &#34;real&#34; data, but just a directed graph of computation steps. PySpark provides a way to get a string representation of the plan, to work with a plan as with a real graph data structure you need to use the Scala/Java API of Apache Spark. When you perform an action, like <code>df.count()</code> or <code>df.write</code>, Spark will get your computation graph and make an execution. This is a very simplified view, because in reality there are many different intermediate steps:</p>
<ul>
<li>Transforming the parsed logical plan into an analyzed logical plan by resolving sources and column references;</li>
<li>Optimizing the logical plan by applying optimization rules (such as moving <code>filter</code> expressions to the beginning of the plan, or moving <code>select</code> expressions to the source column level);</li>
<li>Generate different versions of physical plans based on the same optimized logical plan;</li>
<li>Apply cost-based selection of the best physical plan;</li>
<li>perform code generation based on the selected physical plan;</li>
<li>Execute the code.</li>
</ul>
<p>
For anyone who wants to better understand how spark works with plans and how optimizations can be applied, I highly recommend the book <a href="https://howqueryengineswork.com/00-acknowledgments.html">How query engines work</a> by Andy Grow, creator of the <a href="https://github.com/apache/arrow-datafusion">Apache Arrow Datafusion</a>.</p>
</div>
</div>
<div id="outline-container-headline-4" class="outline-3">
<h3 id="headline-4">
Getting a string-representation of plan in PySpark
</h3>
<div id="outline-text-headline-4" class="outline-text-3">
<p>
But for now, we just need the parsed logical plan, so let&#39;s make a simple Python function that returns it:</p>
<div class="src src-python">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="kn">import</span> <span class="nn">contextlib</span>
</span></span><span class="line"><span class="cl">  <span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="kn">import</span> <span class="n">DataFrame</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="nf">get_logical_plan</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">with</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">redirect_stdout</span><span class="p">(</span><span class="n">StringIO</span><span class="p">())</span> <span class="k">as</span> <span class="n">stdout</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="n">df</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">plan_lines</span> <span class="o">=</span> <span class="n">stdout</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&#34;</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">start_line</span> <span class="o">=</span> <span class="n">plan_lines</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&#34;== Analyzed Logical Plan ==&#34;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">      <span class="n">end_line</span> <span class="o">=</span> <span class="n">plan_lines</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&#34;== Optimized Logical Plan ==&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="s2">&#34;</span><span class="se">\n</span><span class="s2">&#34;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">plan_lines</span><span class="p">[</span><span class="n">start_line</span><span class="p">:</span><span class="n">end_line</span><span class="p">])</span></span></span></code></pre></div>
</div>
<p>
It may look overly complicated, but there is no other way to get a string representation of the analyzed logical plan from PySpark. <code>df.explain</code> returns nothing, instead it prints all plans (analyzed logical, optimized logical, physical) to standard output. That&#39;s why we need to use <code>contextlib.redirect_stdout</code>. You can check what the whole output of <code>df.explain</code> looks like. It is broken up by lines like <code>== Analyzed Logical Plan ==</code> and similar. Also, the analyzed logical plan always starts from the schema of the DataFrame, so we need to add another line.</p>
<p>
Let&#39;s see what the plan looks like for our <code>dat_new</code> DataFrame that we created:</p>
<div class="src src-python">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="n">get_logical_plan</span><span class="p">(</span><span class="n">dat_new</span><span class="p">)</span></span></span></code></pre></div>
</div>
<div class="src src-shell">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">  Aggregate <span class="o">[</span>id1_renamed#2430<span class="o">]</span>, <span class="o">[</span>id1_renamed#2430, count<span class="o">(</span>distinct hash_of_two_ids#2491<span class="o">)</span> AS cnt_ids#2508L, sum<span class="o">((</span>num1#2445 + num2#2454<span class="o">))</span> AS sum_col#2510L<span class="o">]</span>
</span></span><span class="line"><span class="cl">+- Project <span class="o">[</span>id1#1321, id1_renamed#2430, id1_and_id2#2437, num1#2445, num2#2454, hash_id#2469, id4#2480, concat_ws<span class="o">(</span>_, id4#2480, cast<span class="o">(</span>hash_id#2469 as string<span class="o">))</span> AS hash_of_two_ids#2491<span class="o">]</span>
</span></span><span class="line"><span class="cl">   +- Project <span class="o">[</span>id1#1321, id1_renamed#2430, id1_and_id2#2437, num1#2445, num2#2454, hash_id#2469, id4#2480<span class="o">]</span>
</span></span><span class="line"><span class="cl">      +- Join LeftOuter, <span class="o">(</span>id1#1321 <span class="o">=</span> id1#2478<span class="o">)</span>
</span></span><span class="line"><span class="cl">         :- Project <span class="o">[</span>id1_renamed#2430, id1_and_id2#2437, id1#1321, num1#2445, num2#2454, hash<span class="o">(</span>id1_and_id2#2437, 42<span class="o">)</span> AS hash_id#2469<span class="o">]</span>
</span></span><span class="line"><span class="cl">         :  +- Project <span class="o">[</span>id1_renamed#2430, id1_and_id2#2437, id1#1321, num1#2445, num2#2454<span class="o">]</span>
</span></span><span class="line"><span class="cl">         :     +- Filter <span class="o">(</span>rand<span class="o">(</span>-7677477572161899967<span class="o">)</span> &lt;<span class="o">=</span> 0.5<span class="o">)</span>
</span></span><span class="line"><span class="cl">         :        +- Project <span class="o">[</span>id1#1321, id2#1322, id4#1323, id5#1324, v2#1325, id1_renamed#2430, id1_and_id2#2437, num1#2445, <span class="m">2</span> AS num2#2454<span class="o">]</span>
</span></span><span class="line"><span class="cl">         :           +- Project <span class="o">[</span>id1#1321, id2#1322, id4#1323, id5#1324, v2#1325, id1_renamed#2430, id1_and_id2#2437, <span class="m">1</span> AS num1#2445<span class="o">]</span>
</span></span><span class="line"><span class="cl">         :              +- Project <span class="o">[</span>id1#1321, id2#1322, id4#1323, id5#1324, v2#1325, id1_renamed#2430, concat_ws<span class="o">(</span>_, id1#1321, id2#1322<span class="o">)</span> AS id1_and_id2#2437<span class="o">]</span>
</span></span><span class="line"><span class="cl">         :                 +- Project <span class="o">[</span>id1#1321, id2#1322, id4#1323, id5#1324, v2#1325, id1#1321 AS id1_renamed#2430<span class="o">]</span>
</span></span><span class="line"><span class="cl">         :                    +- Relation <span class="o">[</span>id1#1321,id2#1322,id4#1323,id5#1324,v2#1325<span class="o">]</span> csv
</span></span><span class="line"><span class="cl">         +- Project <span class="o">[</span>id1#2478, id4#2480<span class="o">]</span>
</span></span><span class="line"><span class="cl">            +- Relation <span class="o">[</span>id1#2478,id2#2479,id4#2480,id5#2481,v2#2482<span class="o">]</span> csv</span></span></code></pre></div>
</div>
<p>
As you can see, the analyzed logical plan contains all calculation steps from the last one to the first one (<code>Relation ... csv</code>). An important thing is that PySpark adds unique IDs to each column, so the final names in the plan are not real column names, but something like <code>name#unique_id</code>. This will help us a lot when we will create our column lineage parser, because it simplifies all things: you do not need to think about collisions or renaming, because PySpark has already solved all these problems!</p>
</div>
</div>
<div id="outline-container-headline-5" class="outline-3">
<h3 id="headline-5">
Parsing plan to get column-lineage
</h3>
<div id="outline-text-headline-5" class="outline-text-3">
<p>
As you can see, there is a limited list of possible operations:</p>
<ul>
<li><code>Relation</code>: mapping of columns to files or tables;</li>
<li>Project~: any column operation, such as <code>withColumn</code>, <code>withColumnRenamed</code>, <code>select</code>, etc;</li>
<li>Filter~: any filter operation;</li>
<li>Join~: various types of join operations;</li>
<li>Aggregate~: aggregate operations;</li>
</ul>
<p>There are also some additional cases like <code>Union</code>, but the union operation makes things very complex, so let&#39;s decide to avoid it. Just because if a plan contains <code>Union</code> it is very hard to parse it, because a column can appear in any side of a union-like operation…</p>
<div id="outline-container-headline-6" class="outline-4">
<h4 id="headline-6">
Defining an output data-structure and user API
</h4>
<div id="outline-text-headline-6" class="outline-text-4">
<p>
First, we need to define what our column lineage will look like and what the data structure representing the lineage will be. By design, the data lineage is a directed acyclic graph (or tree). One of the simplest ways to represent a graph-like structure is simply to use a list of edges (called an adjacency list). Nodes of our graph will contain not only ids, but also some additional information, like the description of the computation step. Let&#39;s store the attributes in a <code>dict</code>-like structure. And the API should be very simple: just a function that takes a DataFrame object and a column name. For simplicity, it might also be good to store the list of all nodes in the graph. Let&#39;s define the structure and a function signature:</p>
<div class="src src-python">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nd">@dataclass</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">ColumnLineageGraph</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;&#34;&#34;Structure to represent columnar data lineage.&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">nodes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>  <span class="c1"># list of hash values that represent nodes</span>
</span></span><span class="line"><span class="cl">      <span class="n">edges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span>  <span class="c1"># list of edges in the form of list of pairs</span>
</span></span><span class="line"><span class="cl">      <span class="n">node_attrs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>  <span class="c1"># labels of nodes (expressions)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="nf">get_column_lineage</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">columns</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ColumnLineageGraph</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-7" class="outline-4">
<h4 id="headline-7">
Creating recursive parsing function
</h4>
<div id="outline-text-headline-7" class="outline-text-4">
<p>
We will be using a lot of regular expressions and we need to import them first:</p>
<div class="src src-python">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="kn">import</span> <span class="nn">re</span></span></span></code></pre></div>
</div>
<div id="outline-container-headline-8" class="outline-5">
<h5 id="headline-8">
Transforming from graph-nodes to column names
</h5>
<div id="outline-text-headline-8" class="outline-text-5">
<p>
It doesn&#39;t really matter that our logical plan is a list of strings. By design and idea, it is the tree structure, and the best way to traverse the tree is, of course, a recursion. Let&#39;s create an inner recursive function to traverse the plan:</p>
<div class="src src-python">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"> <span class="k">def</span> <span class="nf">_node2column</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;&#34;&#34;Inner function. Transform the node from plan to column name.
</span></span></span><span class="line"><span class="cl"><span class="s2">      Like: col_11#1234L -&gt; col_11.
</span></span></span><span class="line"><span class="cl"><span class="s2">      &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="n">match_</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="k">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&#34;([\w\d]+)#[\w\d]+&#34;</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="n">match_</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="n">match_</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span></span></span></code></pre></div>
</div>
<p>
We also need a way to get a node ID from the column name. To do this, let&#39;s add another simple function:</p>
<div class="src src-python">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="k">def</span> <span class="nf">_get_aliases</span><span class="p">(</span><span class="n">col</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;&#34;&#34;Inner function. Returns all the aliases from the expr and expr itself.&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="n">alias_exp</span> <span class="o">=</span> <span class="n">_extract_alias_expressions</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="c1"># Regexp to extract columns: each column has a pattern like col_name#1234</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&#34;[\w\d]+#[\w\d]+&#34;</span><span class="p">,</span> <span class="n">alias_exp</span><span class="p">),</span> <span class="n">alias_exp</span><span class="p">)</span></span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-9" class="outline-5">
<h5 id="headline-9">
Parsing ALIAS expressions
</h5>
<div id="outline-text-headline-9" class="outline-text-5">
<p>
One of the most complicated cases in a Spark plan is an <code class="verbatim">alias</code>. You may be faced with the following options:</p>
<ul>
<li>Literal expressions, like <code>1 AS col#1234</code>;</li>
<li>Just an alias, like <code>col1#1234 AS col2#1235</code>;</li>
<li>An alias to the expression, like <code>(col1#1234 + col2#1235) AS col3#1236</code>.</li>
</ul>
<p>And the last one can contain an unlimited number of nested expressions. It is almost impossible to parse such a case via regular expressions, looks like we need to balance parentheses, as in <a href="https://leetcode.com/problems/valid-parentheses/description/">Leetcode easy task</a>. I will use a counter based approach, where we have a counter of unbalanced parentheses and we reach the end of the expression when the counter is zero.</p>
<div class="src src-python">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="k">def</span> <span class="nf">_extract_alias_expressions</span><span class="p">(</span><span class="n">col</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;&#34;&#34;Inner function. Extract expression before ... AS col from the line.&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="n">num_close_parentheses</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># our counter</span>
</span></span><span class="line"><span class="cl">      <span class="n">idx</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34; AS </span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span> <span class="c1"># the end of the alias expression we need to parse</span>
</span></span><span class="line"><span class="cl">      <span class="n">alias_expr</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># buffer to store what we are parsing</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&#34;)&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="s2">&#34;&#34;&#34;It is possible that there is no expression.
</span></span></span><span class="line"><span class="cl"><span class="s2">          It is the case when we just make a rename of the column. In the plan
</span></span></span><span class="line"><span class="cl"><span class="s2">          it will look like `col#123 AS col#321`;
</span></span></span><span class="line"><span class="cl"><span class="s2">          &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">          <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">              <span class="n">alias_expr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">              <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&#34;[&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                  <span class="k">break</span>
</span></span><span class="line"><span class="cl">              <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&#34; &#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                  <span class="k">break</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="s2">&#34;&#34;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">alias_expr</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;&#34;&#34;In all other cases there will be `(` at the end of the expr before AS.
</span></span></span><span class="line"><span class="cl"><span class="s2">      Our goal is to go symbol by symbol back until we balance all the parentheses.
</span></span></span><span class="line"><span class="cl"><span class="s2">      &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">          <span class="n">alias_expr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&#34;)&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">              <span class="c1"># Add parenthesis</span>
</span></span><span class="line"><span class="cl">              <span class="n">num_close_parentheses</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&#34;(&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">              <span class="k">if</span> <span class="n">num_close_parentheses</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                  <span class="c1"># Parentheses are balanced</span>
</span></span><span class="line"><span class="cl">                  <span class="k">break</span>
</span></span><span class="line"><span class="cl">              <span class="c1"># Remove parenthesis</span>
</span></span><span class="line"><span class="cl">              <span class="n">num_close_parentheses</span> <span class="o">-=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;&#34;&#34;After balancing parentheses we need to parse leading expression.
</span></span></span><span class="line"><span class="cl"><span class="s2">      It is always here because we checked single alias case separately.&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">          <span class="n">alias_expr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&#34;[&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">              <span class="k">break</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&#34; &#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">              <span class="k">break</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="s2">&#34;&#34;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">alias_expr</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></span></span></code></pre></div>
</div>
<p>
It may look like magic, so let&#39;s check how it works on examples from our real plan representation:</p>
<div class="src src-python">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="n">_extract_alias_expressions</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;id1_and_id2#2437&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;Project [id1#1321, id2#1322, id4#1323, id5#1324, v2#1325, id1_renamed#2430, concat_ws(_, id1#1321, id2#1322) AS id1_and_id2#2437]&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span></span></span></code></pre></div>
</div>
<p>
And the result is:</p>
<div class="src src-shell">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">  <span class="s1">&#39;concat_ws((_, id1#1321, id2#1322)&#39;</span></span></span></code></pre></div>
</div>
<p>
Looks like it works! Finally some of the knowledge from the Leetcode tasks was put into practice!</p>
</div>
</div>
<div id="outline-container-headline-10" class="outline-5">
<h5 id="headline-10">
Parsing aggregation-like expressions
</h5>
<div id="outline-text-headline-10" class="outline-text-5">
<p>
In most cases we do not need additional columns from the row of the plan, except for one that we are working with. The only exception is aggregation: it might be good to store information about aggregation keys in our final node attributes. Let&#39;s add a simple function to do this:</p>
<div class="src src-python">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="k">def</span> <span class="nf">_add_aggr_or_not</span><span class="p">(</span><span class="n">expr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;&#34;&#34;If the expr is aggregation we should add agg keys to the beginning.&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="c1"># We are checking for aggregation pattern</span>
</span></span><span class="line"><span class="cl">      <span class="n">match_</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="k">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&#34;^[\s\+\-:]*Aggregate\s\[([\w\d#,\s]+)\].*$&#34;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="n">match_</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="n">agg_expr</span> <span class="o">=</span> <span class="n">match_</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="s2">&#34;GroupBy: &#34;</span> <span class="o">+</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&#34;([\w\d]+)#([\w\d]+)&#34;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&#34;\1&#34;</span><span class="p">,</span> <span class="n">agg_expr</span><span class="p">)</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&#34;</span><span class="se">\n</span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">          <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1"># If not just return an original expr</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">expr</span></span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-11" class="outline-5">
<h5 id="headline-11">
Building a final recursive parser
</h5>
<div id="outline-text-headline-11" class="outline-text-5">
<p>
Now we have everything we need. So let&#39;s go through the logical plan line by line, adding nodes and attributes to our graph structure:</p>
<div class="src src-python">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="k">def</span> <span class="nf">_get_graph</span><span class="p">(</span><span class="n">lines</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">      <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">      <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">      <span class="n">node_attrs</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>  <span class="c1"># noqa: E741</span>
</span></span><span class="line"><span class="cl">          <span class="s2">&#34;&#34;&#34;Iteration over lines of logical plan.&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="c1"># We should use hash of line + node as a key in the graph.</span>
</span></span><span class="line"><span class="cl">          <span class="c1"># It is not enough to use only hash of line because the same line</span>
</span></span><span class="line"><span class="cl">          <span class="c1"># may be related to multiple nodes!</span>
</span></span><span class="line"><span class="cl">          <span class="c1"># A good example is reading the CSV that is represented by one line!</span>
</span></span><span class="line"><span class="cl">          <span class="n">h</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">node</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="c1"># If the current node is not root we need to store hash of previous node.</span>
</span></span><span class="line"><span class="cl">          <span class="n">prev_h</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">nodes</span> <span class="k">else</span> <span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">              <span class="k">continue</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="sa">f</span><span class="s2">&#34;AS </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&#34;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">              <span class="s2">&#34;&#34;&#34;It is a hard case, when a node is an alias to some expression.&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">              <span class="n">aliases</span><span class="p">,</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">_get_aliases</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="c1"># For visualization we need to transform from nodes to columns</span>
</span></span><span class="line"><span class="cl">              <span class="n">expr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&#34;([\w\d]+)#([\w\d]+)&#34;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&#34;\1&#34;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              <span class="c1"># Append a new node</span>
</span></span><span class="line"><span class="cl">              <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="c1"># Append expr as an attribute of the node</span>
</span></span><span class="line"><span class="cl">              <span class="n">node_attrs</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">_add_aggr_or_not</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;</span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s2"> AS </span><span class="si">{</span><span class="n">_node2column</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aliases</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                  <span class="c1"># It is the case of simple alis</span>
</span></span><span class="line"><span class="cl">                  <span class="c1"># Like col1#123 AS col2#321</span>
</span></span><span class="line"><span class="cl">                  <span class="c1"># In this case we just replace an old node by new one.</span>
</span></span><span class="line"><span class="cl">                  <span class="k">if</span> <span class="n">prev_h</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                      <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">h</span><span class="p">,</span> <span class="n">prev_h</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                  <span class="n">node</span> <span class="o">=</span> <span class="n">aliases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">              <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                  <span class="c1"># It is a case of complex expression.</span>
</span></span><span class="line"><span class="cl">                  <span class="c1"># Here we recursively go through all the nodes from expr.</span>
</span></span><span class="line"><span class="cl">                  <span class="k">if</span> <span class="n">prev_h</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                      <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">h</span><span class="p">,</span> <span class="n">prev_h</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                  <span class="k">for</span> <span class="n">aa</span> <span class="ow">in</span> <span class="n">aliases</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                      <span class="c1"># Get graph from sub-column</span>
</span></span><span class="line"><span class="cl">                      <span class="n">sub_nodes</span><span class="p">,</span> <span class="n">sub_edges</span><span class="p">,</span> <span class="n">sub_attrs</span> <span class="o">=</span> <span class="n">_get_graph</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">aa</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                      <span class="c1"># Add everything to the current graph</span>
</span></span><span class="line"><span class="cl">                      <span class="n">nodes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sub_nodes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                      <span class="n">edges</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sub_edges</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                      <span class="n">node_attrs</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">node_attrs</span><span class="p">,</span> <span class="o">**</span><span class="n">sub_attrs</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                      <span class="c1"># Add connection between top subnode and node</span>
</span></span><span class="line"><span class="cl">                      <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">sub_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">h</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                  <span class="k">return</span> <span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">node_attrs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">              <span class="c1"># Continue of the simple alias or expr case</span>
</span></span><span class="line"><span class="cl">              <span class="c1"># In the future that may be more cases, that is the reason of nested if instead of elif</span>
</span></span><span class="line"><span class="cl">              <span class="k">if</span> <span class="s2">&#34;Relation&#34;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                  <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="k">if</span> <span class="n">prev_h</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                      <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">h</span><span class="p">,</span> <span class="n">prev_h</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                  <span class="c1"># It is a pattern, related to data-sources (like CSV)</span>
</span></span><span class="line"><span class="cl">                  <span class="n">match_</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="k">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&#34;[\s\+\-:]*Relation\s\[.*\]\s(\w+)&#34;</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="k">if</span> <span class="n">match_</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                      <span class="n">s_</span> <span class="o">=</span> <span class="s2">&#34;Read from </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">                      <span class="c1"># Add data-source as a node</span>
</span></span><span class="line"><span class="cl">                      <span class="n">node_attrs</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">match_</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_node2column</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                  <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                      <span class="c1"># We need it to avoid empty graphs and related runtime exceptions</span>
</span></span><span class="line"><span class="cl">                      <span class="nb">print</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                      <span class="n">node_attrs</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&#34;Relation to: </span><span class="si">{</span><span class="n">_node2column</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">              <span class="k">elif</span> <span class="s2">&#34;Join&#34;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                  <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="k">if</span> <span class="n">prev_h</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                      <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">h</span><span class="p">,</span> <span class="n">prev_h</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                  <span class="n">match_</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="k">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&#34;[\s\+\-:]*Join\s(\w+),\s\((.*)\)&#34;</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="k">if</span> <span class="n">match_</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                      <span class="n">join_type</span> <span class="o">=</span> <span class="n">match_</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                      <span class="n">join_expr</span> <span class="o">=</span> <span class="n">match_</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                      <span class="n">join_expr_clr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&#34;([\w\d]+)#([\w\d]+)&#34;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&#34;\1&#34;</span><span class="p">,</span> <span class="n">join_expr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                      <span class="n">node_attrs</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&#34;</span><span class="si">{</span><span class="n">join_type</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">join_expr_clr</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">              <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                  <span class="k">continue</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="ow">not</span> <span class="n">nodes</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="c1"># Just the case of empty return. We need to avoid it.</span>
</span></span><span class="line"><span class="cl">          <span class="c1"># I&#39;m not sure that line is reachable.</span>
</span></span><span class="line"><span class="cl">          <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="n">node_attrs</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&#34;Select: </span><span class="si">{</span><span class="n">_node2column</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">node_attrs</span><span class="p">)</span></span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-12" class="outline-5">
<h5 id="headline-12">
All together
</h5>
<div id="outline-text-headline-12" class="outline-text-5">
<p>
Now we are ready to put all the pieces together into a single function:</p>
<div class="src src-python">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="k">def</span> <span class="nf">get_column_lineage</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">column</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ColumnLineageGraph</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;&#34;&#34;Get data lineage on the level of the given column.
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">      Currently Union operation is not supported! API is unstable, no guarantee
</span></span></span><span class="line"><span class="cl"><span class="s2">      that custom spark operations or connectors won&#39;t break it!
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">      :param df: DataFrame
</span></span></span><span class="line"><span class="cl"><span class="s2">      :param column: column
</span></span></span><span class="line"><span class="cl"><span class="s2">      :returns: Struct with nodes, edges and attributes
</span></span></span><span class="line"><span class="cl"><span class="s2">      &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="n">lines</span> <span class="o">=</span> <span class="n">get_plan_from_df</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">PlanType</span><span class="o">.</span><span class="n">ANALYZED_LOGICAL_PLAN</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&#34;</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1"># Top line should contain plan-id of our column. We need it.</span>
</span></span><span class="line"><span class="cl">      <span class="c1"># Regular pattern of node is column#12345L or [\w\d]+#[\w\d]+</span>
</span></span><span class="line"><span class="cl">      <span class="n">match_</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="k">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&#34;.*(&#34;</span> <span class="o">+</span> <span class="n">column</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&#34;#[\w\d]+).*&#34;</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="n">match_</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="n">node</span> <span class="o">=</span> <span class="n">match_</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="n">err</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&#34;There is no column </span><span class="si">{</span><span class="n">column</span><span class="si">}</span><span class="s2"> in the final schema of DF!&#34;</span>
</span></span><span class="line"><span class="cl">          <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">attrs</span> <span class="o">=</span> <span class="n">_get_graph</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">ColumnLineageGraph</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span></span></span></code></pre></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-13" class="outline-3">
<h3 id="headline-13">
Testing and drawing our implementation
</h3>
<div id="outline-text-headline-13" class="outline-text-3">
<p>
Let&#39;s see how our function works:</p>
<div class="src src-python">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="n">get_column_lineage</span><span class="p">(</span><span class="n">dat_new</span><span class="p">,</span> <span class="s2">&#34;cnt_ids&#34;</span><span class="p">)</span></span></span></code></pre></div>
</div>
<p>
Will produce the following:</p>
<div class="src src-shell">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">  ColumnLineageGraph<span class="o">(</span><span class="nv">nodes</span><span class="o">=[</span>-3047688324833821294, 8934572903754805890, -22248459158511064, -3092611391038289840, 1490298382268190732, -6431655222193019101, -1002279244933706460<span class="o">]</span>, <span class="nv">edges</span><span class="o">=[[</span>8934572903754805890, -3047688324833821294<span class="o">]</span>, <span class="o">[</span>-22248459158511064, 8934572903754805890<span class="o">]</span>, <span class="o">[</span>1490298382268190732, -3092611391038289840<span class="o">]</span>, <span class="o">[</span>-6431655222193019101, 1490298382268190732<span class="o">]</span>, <span class="o">[</span>-1002279244933706460, 1490298382268190732<span class="o">]</span>, <span class="o">[</span>-3092611391038289840, 8934572903754805890<span class="o">]]</span>, <span class="nv">node_attrs</span><span class="o">={</span>-3047688324833821294: <span class="s1">&#39;GroupBy: id1_renamed\ncount((distinct hash_of_two_ids) AS cnt_ids&#39;</span>, 8934572903754805890: <span class="s1">&#39;concat_ws((_, id4, cast(hash_id as string)) AS hash_of_two_ids&#39;</span>, -22248459158511064: <span class="s1">&#39;Read from csv: id4&#39;</span>, -3092611391038289840: <span class="s1">&#39;hash((id1_and_id2, 42) AS hash_id&#39;</span>, 1490298382268190732: <span class="s1">&#39;concat_ws((_, id1, id2) AS id1_and_id2&#39;</span>, -6431655222193019101: <span class="s1">&#39;Read from csv: id1&#39;</span>, -1002279244933706460: <span class="s1">&#39;Read from csv: id2&#39;</span><span class="o">})</span></span></span></code></pre></div>
</div>
<p>
Looks like it works, at least in our simple case.</p>
<div id="outline-container-headline-14" class="outline-4">
<h4 id="headline-14">
Drawing the graph
</h4>
<div id="outline-text-headline-14" class="outline-text-4">
<p>
To draw the graph as a tree, let&#39;s use the Python library <a href="https://networkx.org/">NetworkX</a>. And <a href="https://graphviz.org/">GraphViz</a> as the drawing engine. You need to install the following packages to use it:</p>
<ul>
<li><code>networkx</code></li>
<li><code>pygraphviz</code></li>
<li><code>matplotlib</code></li>
</ul>
<div class="src src-python">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="k">def</span> <span class="nf">plot_column_lineage_graph</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">df</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&#34;matplotlib.pyplot.Figure&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="s2">&#34;&#34;&#34;Plot the column lineage graph as matplotlib figure.
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">      :param df: DataFrame
</span></span></span><span class="line"><span class="cl"><span class="s2">      :param column: column
</span></span></span><span class="line"><span class="cl"><span class="s2">      :returns: matplotlib.pyplot.Figure
</span></span></span><span class="line"><span class="cl"><span class="s2">      &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
</span></span><span class="line"><span class="cl">          <span class="kn">from</span> <span class="nn">networkx.drawing.nx_agraph</span> <span class="kn">import</span> <span class="n">graphviz_layout</span>
</span></span><span class="line"><span class="cl">      <span class="k">except</span> <span class="ne">ModuleNotFoundError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="n">err</span> <span class="o">=</span> <span class="s2">&#34;NetworkX is not installed. Try `pip install networkx`. &#34;</span>
</span></span><span class="line"><span class="cl">          <span class="n">err</span> <span class="o">+=</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="s2">&#34;You may use `get_column_lineage` instead, that doesn&#39;t require NetworkX.&#34;</span>
</span></span><span class="line"><span class="cl">          <span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</span></span><span class="line"><span class="cl">      <span class="k">except</span> <span class="ne">ModuleNotFoundError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="n">err</span> <span class="o">=</span> <span class="s2">&#34;You need matplotlib installed to draw the Graph&#34;</span>
</span></span><span class="line"><span class="cl">          <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="kn">import</span> <span class="n">importlib</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="ow">not</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="s2">&#34;pygraphviz&#34;</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">          <span class="n">err</span> <span class="o">=</span> <span class="s2">&#34;You need to have pygraphviz installed to draw the Graph&#34;</span>
</span></span><span class="line"><span class="cl">          <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">lineage</span> <span class="o">=</span> <span class="n">get_column_lineage</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">g</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">g</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">lineage</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">g</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">lineage</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">pos</span> <span class="o">=</span> <span class="n">graphviz_layout</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">prog</span><span class="o">=</span><span class="s2">&#34;twopi&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">pos_attrs</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">pos</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">          <span class="n">pos_attrs</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_labels</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">lineage</span><span class="o">.</span><span class="n">node_attrs</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos_attrs</span><span class="p">,</span> <span class="n">clip_on</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span></span></span></code></pre></div>
</div>
<p>
If we run it, we get the following:</p>
<div class="src src-python">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</span></span><span class="line"><span class="cl">  <span class="n">col</span> <span class="o">=</span> <span class="s2">&#34;cnt_ids&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span> <span class="o">=</span> <span class="n">plot_column_lineage_graph</span><span class="p">(</span><span class="n">dat_new</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></span></span></code></pre></div>
</div>
<p>
<figure>
    <img loading="lazy" src="/ssinchenko/images/pyspark-column-lineage.png"
         alt="Column lineage" width="750px"/> 
</figure>
</p>
<p>
Looks exactly as what we need!</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-15" class="outline-3">
<h3 id="headline-15">
Afterwards
</h3>
<div id="outline-text-headline-15" class="outline-text-3">
<p>
This functionality is mostly for educational purposes, to better understand how Spark Plan is organized. Another possible use case is if you need some simple inline Python code for this task. For real production data lineage on top of Spark, I recommend using a <a href="https://github.com/AbsaOSS/spline-spark-agent">Spline Project</a>!</p>
</div>
</div>
</div>
</div>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/ssinchenko/tags/spark/">Spark</a></li>
      <li><a href="http://localhost:1313/ssinchenko/tags/pyspark/">Pyspark</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/ssinchenko/post/how-databricks-14x-breaks-3dparty-compatibility/">
    <span class="title">« Prev</span>
    <br>
    <span>How Databricks Runtime 14.x destroyed 3d-party PySpark packages compatibility</span>
  </a>
  <a class="next" href="http://localhost:1313/ssinchenko/post/estimation-spark-df-size/">
    <span class="title">Next »</span>
    <br>
    <span>How to estimate a PySpark DF size?</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PySpark column lineage on x"
            href="https://x.com/intent/tweet/?text=PySpark%20column%20lineage&amp;url=http%3a%2f%2flocalhost%3a1313%2fssinchenko%2fpost%2fpyspark-column-lineage%2f&amp;hashtags=spark%2cpyspark">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PySpark column lineage on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fssinchenko%2fpost%2fpyspark-column-lineage%2f&amp;title=PySpark%20column%20lineage&amp;summary=PySpark%20column%20lineage&amp;source=http%3a%2f%2flocalhost%3a1313%2fssinchenko%2fpost%2fpyspark-column-lineage%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PySpark column lineage on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fssinchenko%2fpost%2fpyspark-column-lineage%2f&title=PySpark%20column%20lineage">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PySpark column lineage on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fssinchenko%2fpost%2fpyspark-column-lineage%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PySpark column lineage on whatsapp"
            href="https://api.whatsapp.com/send?text=PySpark%20column%20lineage%20-%20http%3a%2f%2flocalhost%3a1313%2fssinchenko%2fpost%2fpyspark-column-lineage%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PySpark column lineage on telegram"
            href="https://telegram.me/share/url?text=PySpark%20column%20lineage&amp;url=http%3a%2f%2flocalhost%3a1313%2fssinchenko%2fpost%2fpyspark-column-lineage%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share PySpark column lineage on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=PySpark%20column%20lineage&u=http%3a%2f%2flocalhost%3a1313%2fssinchenko%2fpost%2fpyspark-column-lineage%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://localhost:1313/ssinchenko/">Sem Sinchenko</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
